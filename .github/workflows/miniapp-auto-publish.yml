# ============================================================================
# Internal MiniApps Auto-Build & Publish Workflow
# ============================================================================
# Automatically builds and publishes internal MiniApps when source code changes
#
# Triggered by:
# - Push to main/master branch with changes in miniapps-uniapp/apps/*
# - Manual workflow dispatch
#
# Process:
# 1. Detect which MiniApps have changed
# 2. Build each changed MiniApp
# 3. Upload to Vercel Blob Storage
# 4. Update miniapp_internal table in Supabase
# ============================================================================

name: Internal MiniApps Auto-Publish

on:
  push:
    branches: [main, master]
    paths:
      - "miniapps-uniapp/apps/**"
      - ".github/workflows/miniapp-auto-publish.yml"
  workflow_dispatch: # Allow manual trigger

env:
  NODE_VERSION: "20"
  PNPM_VERSION: "9"

jobs:
  # Job 1: Detect changed MiniApps
  detect:
    name: Detect Changed Apps
    runs-on: ubuntu-latest
    outputs:
      changed-apps: ${{ steps.detect.outputs.changed-apps }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # Only need last 2 commits for diff

      - name: Detect changed MiniApps
        id: detect
        run: |
          # Get list of changed apps (safe, no untrusted input)
          changed_apps=$(git diff --name-only HEAD~1 HEAD | \
            rg '^miniapps-uniapp/apps/([^/]+)' --only-matching --replace '$1' | \
            sort -u | \
            jq -R -s -c 'split("\n")[:-1]')

          # Check if any apps changed
          if [ -z "$changed_apps" ] || [ "$changed_apps" = "[]" ]; then
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "changed-apps=[]" >> $GITHUB_OUTPUT
            echo "No MiniApp changes detected"
          else
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "changed-apps=$changed_apps" >> $GITHUB_OUTPUT
            echo "Changed MiniApps: $changed_apps"
          fi

  # Job 2: Build and publish each changed app
  build:
    name: Build & Publish ${{ matrix.app }}
    needs: detect
    if: needs.detect.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJson(needs.detect.outputs.changed-apps) }}
      max-parallel: 3 # Build up to 3 apps in parallel
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Get app info
        id: app-info
        run: |
          app_path="miniapps-uniapp/apps/${{ matrix.app }}"

          # Read manifest (safe, only reading our own files)
          if [ -f "$app_path/neo-manifest.json" ]; then
            manifest=$(cat "$app_path/neo-manifest.json")
            app_id=$(echo "$manifest" | jq -r '.app_id')
            app_name=$(echo "$manifest" | jq -r '.name // "'${{ matrix.app }}'"')
            category=$(echo "$manifest" | jq -r '.category // "uncategorized"')
            echo "app_id=$app_id" >> $GITHUB_OUTPUT
            echo "app_name=$app_name" >> $GITHUB_OUTPUT
            echo "category=$category" >> $GITHUB_OUTPUT
            echo "Detected app_id: $app_id"
          else
            echo "error=neo-manifest.json not found" >&2
            exit 1
          fi

      - name: Install dependencies
        working-directory: miniapps-uniapp/apps/${{ matrix.app }}
        run: pnpm install --frozen-lockfile=false

      - name: Build MiniApp
        id: build
        working-directory: miniapps-uniapp/apps/${{ matrix.app }}
        run: |
          pnpm build

          # Check if build succeeded
          if [ ! -d "dist" ] && [ ! -d "build" ]; then
            echo "error=Build output not found" >&2
            exit 1
          fi

          # Determine build output directory
          if [ -d "dist" ]; then
            build_dir="dist"
          else
            build_dir="build"
          fi

          echo "build_dir=$build_dir" >> $GITHUB_OUTPUT
          echo "Build completed successfully"

      - name: Setup Vercel CLI
        run: npm install --global vercel@latest

      - name: Upload to Vercel Blob Storage
        id: upload
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_BLOB_TOKEN }}
          VERCEL_TEAM_ID: ${{ secrets.VERCEL_TEAM_ID }}
          BUILD_DIR: ${{ steps.build.outputs.build_dir }}
          APP_ID: ${{ steps.app-info.outputs.app_id }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Create version path from commit SHA (short)
          version_path="${COMMIT_SHA:0:8}"
          cdn_prefix="miniapps/${APP_ID}/${version_path}"

          echo "Uploading to: ${cdn_prefix}"

          # Upload build output to Vercel Blob
          # Using vercel blob deploy command
          cd "${BUILD_DIR}"

          # Upload all files
          upload_response=$(vercel blob deploy . --to-path "${cdn_prefix}" 2>&1)

          echo "Upload response: ${upload_response}"

          # Extract URLs from response
          # Vercel blob deploy returns URLs in the output
          base_url="https://blob.vercel-storage.com/${cdn_prefix}/"

          echo "base_url=${base_url}" >> $GITHUB_OUTPUT
          echo "version_path=${version_path}" >> $GITHUB_OUTPUT

          # Upload icon if exists
          icon_path="../../static/icon.png"
          if [ -f "${icon_path}" ]; then
            vercel blob deploy "${icon_path}" --to-path "miniapps/${APP_ID}/assets/icon.png"
            echo "icon_url=https://blob.vercel-storage.com/miniapps/${APP_ID}/assets/icon.png" >> $GITHUB_OUTPUT
          fi

          # Upload banner if exists
          banner_path="../../static/banner.png"
          if [ -f "${banner_path}" ]; then
            vercel blob deploy "${banner_path}" --to-path "miniapps/${APP_ID}/assets/banner.png"
            echo "banner_url=https://blob.vercel-storage.com/miniapps/${APP_ID}/assets/banner.png" >> $GITHUB_OUTPUT
          fi

      - name: Update Supabase database
        id: update-db
        env:
          APP_ID: ${{ steps.app-info.outputs.app_id }}
          APP_NAME: ${{ steps.app-info.outputs.app_name }}
          CATEGORY: ${{ steps.app-info.outputs.category }}
          SUBFOLDER: "miniapps-uniapp/apps/${{ matrix.app }}"
          BASE_URL: ${{ steps.upload.outputs.base_url }}
          VERSION_PATH: ${{ steps.upload.outputs.version_path }}
          ICON_URL: ${{ steps.upload.outputs.icon_url }}
          BANNER_URL: ${{ steps.upload.outputs.banner_url }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Read manifest
          manifest=$(cat "miniapps-uniapp/apps/${{ matrix.app }}/neo-manifest.json")

          # Update miniapp_internal table
          response=$(curl -s -X POST \
            "${{ secrets.SUPABASE_URL }}/functions/v1/miniapp-internal/update" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"app_id\": \"${APP_ID}\",
              \"name\": \"${APP_NAME}\",
              \"category\": \"${CATEGORY}\",
              \"subfolder\": \"${SUBFOLDER}\",
              \"manifest\": ${manifest},
              \"entry_url\": \"${BASE_URL}index.html\",
              \"icon_url\": \"${ICON_URL}\",
              \"banner_url\": \"${BANNER_URL}\",
              \"current_version\": \"${VERSION_PATH}\",
              \"commit_sha\": \"${COMMIT_SHA}\"
            }")

          echo "Database update response: ${response}"

          # Check for errors
          if echo "${response}" | jq -e '.error' > /dev/null; then
            echo "Failed to update database"
            echo "${response}" | jq -r '.error' >&2
            exit 1
          fi

          echo "entry_url=${BASE_URL}index.html" >> $GITHUB_OUTPUT

      - name: Verify publication
        run: |
          # Query miniapp_internal table to verify
          response=$(curl -s \
            "${{ secrets.SUPABASE_URL }}/rest/v1/miniapp_internal?app_id=eq.${{ steps.app-info.outputs.app_id }}" \
            -H "Authorization: Bearer ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" \
            -H "apikey: ${{ secrets.SUPABASE_ANON_KEY }}")

          echo "Verification response: ${response}"

          if echo "${response}" | jq -e '.[0]' > /dev/null; then
            echo "✅ MiniApp published successfully"
            echo "   App ID: ${{ steps.app-info.outputs.app_id }}"
            echo "   Entry URL: ${{ steps.update-db.outputs.entry_url }}"
          else
            echo "❌ Failed to verify publication"
            exit 1
          fi

  # Job 3: Summary
  summary:
    name: Publication Summary
    needs: [detect, build]
    if: always() && needs.detect.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Create summary
        run: |
          changed_apps='${{ needs.detect.outputs.changed-apps }}'
          echo "## MiniApp Auto-Publish Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Changed Apps**: $changed_apps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.build.result }}" = "success" ]; then
            echo "✅ All apps published successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️ Some apps failed to publish" >> $GITHUB_STEP_SUMMARY
          fi
