/*
 * Enclave Definition Language (EDL) File
 *
 * This file defines the interface between the untrusted application
 * and the trusted enclave. It specifies:
 *   - ECALLs: Functions called from untrusted code into the enclave
 *   - OCALLs: Functions called from the enclave to untrusted code
 *
 * Security considerations:
 *   - All data crossing the enclave boundary must be explicitly sized
 *   - Use [in] for data going into enclave, [out] for data coming out
 *   - Use [user_check] for pointers that the enclave will validate itself
 */

enclave {
    /* Import standard SGX trusted libraries */
    from "sgx_tstdc.edl" import *;
    from "sgx_pthread.edl" import *;

    /* Trusted functions (ECALLs) - called from untrusted code */
    trusted {
        /*
         * Initialize the enclave.
         * Must be called before any other ECALL.
         *
         * @param enclave_id_out  Output buffer for enclave ID (32 bytes)
         * @param enclave_id_len  Size of output buffer
         * @return                SGX_SUCCESS on success
         */
        public sgx_status_t ecall_initialize(
            [out, size=enclave_id_len] uint8_t* enclave_id_out,
            size_t enclave_id_len
        );

        /*
         * Health check - verify enclave is operational.
         *
         * @return  SGX_SUCCESS if healthy
         */
        public sgx_status_t ecall_health_check();

        /*
         * Seal data using the enclave's sealing key (MRSIGNER policy).
         *
         * @param plaintext         Data to seal
         * @param plaintext_len     Length of plaintext
         * @param additional_data   Additional authenticated data (optional)
         * @param additional_len    Length of additional data
         * @param sealed_out        Output buffer for sealed data
         * @param sealed_buf_len    Size of output buffer
         * @param sealed_len_out    Actual sealed data length
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_seal_data(
            [in, size=plaintext_len] const uint8_t* plaintext,
            size_t plaintext_len,
            [in, size=additional_len] const uint8_t* additional_data,
            size_t additional_len,
            [out, size=sealed_buf_len] uint8_t* sealed_out,
            size_t sealed_buf_len,
            [out] size_t* sealed_len_out
        );

        /*
         * Unseal data that was previously sealed.
         *
         * @param sealed            Sealed data
         * @param sealed_len        Length of sealed data
         * @param plaintext_out     Output buffer for plaintext
         * @param plaintext_buf_len Size of output buffer
         * @param plaintext_len_out Actual plaintext length
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_unseal_data(
            [in, size=sealed_len] const uint8_t* sealed,
            size_t sealed_len,
            [out, size=plaintext_buf_len] uint8_t* plaintext_out,
            size_t plaintext_buf_len,
            [out] size_t* plaintext_len_out
        );

        /*
         * Generate an SGX report for remote attestation.
         *
         * @param report_data       User data to include in report (max 64 bytes)
         * @param report_data_len   Length of report data
         * @param target_info       Target enclave info (for local attestation)
         * @param report_out        Output: SGX report structure
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_generate_report(
            [in, size=report_data_len] const uint8_t* report_data,
            size_t report_data_len,
            [in] const sgx_target_info_t* target_info,
            [out] sgx_report_t* report_out
        );

        /*
         * Get enclave measurements (MRENCLAVE and MRSIGNER).
         *
         * @param mr_enclave_out    Output: MRENCLAVE (32 bytes)
         * @param mr_signer_out     Output: MRSIGNER (32 bytes)
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_get_enclave_info(
            [out, size=32] uint8_t* mr_enclave_out,
            [out, size=32] uint8_t* mr_signer_out
        );

        /*
         * Generate an ECDSA P-256 key pair inside the enclave.
         *
         * @param key_id            Unique identifier for the key
         * @param key_id_len        Length of key ID
         * @param public_key_out    Output: Public key (65 bytes, uncompressed)
         * @param public_key_len    Size of public key buffer
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_generate_ecdsa_keypair(
            [in, size=key_id_len] const uint8_t* key_id,
            size_t key_id_len,
            [out, size=public_key_len] uint8_t* public_key_out,
            size_t public_key_len
        );

        /*
         * Sign data using ECDSA P-256.
         *
         * @param key_id            Key identifier
         * @param key_id_len        Length of key ID
         * @param data              Data to sign
         * @param data_len          Length of data
         * @param signature_out     Output: Signature (64 bytes, r||s)
         * @param signature_len     Size of signature buffer
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_ecdsa_sign(
            [in, size=key_id_len] const uint8_t* key_id,
            size_t key_id_len,
            [in, size=data_len] const uint8_t* data,
            size_t data_len,
            [out, size=signature_len] uint8_t* signature_out,
            size_t signature_len
        );

        /*
         * Compute SHA-256 hash inside the enclave.
         *
         * @param data              Data to hash
         * @param data_len          Length of data
         * @param hash_out          Output: Hash (32 bytes)
         * @param hash_len          Size of hash buffer
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_sha256(
            [in, size=data_len] const uint8_t* data,
            size_t data_len,
            [out, size=hash_len] uint8_t* hash_out,
            size_t hash_len
        );

        /*
         * AES-256-GCM encryption inside the enclave.
         *
         * @param key               Encryption key (32 bytes)
         * @param key_len           Key length (must be 32)
         * @param iv                Initialization vector (12 bytes)
         * @param iv_len            IV length (must be 12)
         * @param plaintext         Data to encrypt
         * @param plaintext_len     Length of plaintext
         * @param aad               Additional authenticated data (optional)
         * @param aad_len           Length of AAD
         * @param ciphertext_out    Output: Ciphertext
         * @param ciphertext_len    Size of ciphertext buffer
         * @param tag_out           Output: Authentication tag (16 bytes)
         * @param tag_len           Size of tag buffer
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_aes_gcm_encrypt(
            [in, size=key_len] const uint8_t* key,
            size_t key_len,
            [in, size=iv_len] const uint8_t* iv,
            size_t iv_len,
            [in, size=plaintext_len] const uint8_t* plaintext,
            size_t plaintext_len,
            [in, size=aad_len] const uint8_t* aad,
            size_t aad_len,
            [out, size=ciphertext_len] uint8_t* ciphertext_out,
            size_t ciphertext_len,
            [out, size=tag_len] uint8_t* tag_out,
            size_t tag_len
        );

        /*
         * AES-256-GCM decryption inside the enclave.
         *
         * @param key               Decryption key (32 bytes)
         * @param key_len           Key length (must be 32)
         * @param iv                Initialization vector (12 bytes)
         * @param iv_len            IV length (must be 12)
         * @param ciphertext        Data to decrypt
         * @param ciphertext_len    Length of ciphertext
         * @param aad               Additional authenticated data (optional)
         * @param aad_len           Length of AAD
         * @param tag               Authentication tag (16 bytes)
         * @param tag_len           Tag length (must be 16)
         * @param plaintext_out     Output: Plaintext
         * @param plaintext_buf_len Size of plaintext buffer
         * @return                  SGX_SUCCESS on success
         */
        public sgx_status_t ecall_aes_gcm_decrypt(
            [in, size=key_len] const uint8_t* key,
            size_t key_len,
            [in, size=iv_len] const uint8_t* iv,
            size_t iv_len,
            [in, size=ciphertext_len] const uint8_t* ciphertext,
            size_t ciphertext_len,
            [in, size=aad_len] const uint8_t* aad,
            size_t aad_len,
            [in, size=tag_len] const uint8_t* tag,
            size_t tag_len,
            [out, size=plaintext_buf_len] uint8_t* plaintext_out,
            size_t plaintext_buf_len
        );
    };

    /* Untrusted functions (OCALLs) - called from enclave to untrusted code */
    untrusted {
        /*
         * Print debug message (development only).
         * Should be disabled in production builds.
         */
        void ocall_print_string([in, string] const char* str);

        /*
         * Get current time (for timestamps).
         * Note: Time from untrusted code should not be trusted for security.
         */
        uint64_t ocall_get_time();

        /*
         * Read random bytes from /dev/urandom (fallback).
         * Prefer SGX's RDRAND instruction when available.
         */
        sgx_status_t ocall_read_rand(
            [out, size=size] uint8_t* buf,
            size_t size
        );
    };
};
