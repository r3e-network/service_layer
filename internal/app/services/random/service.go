package random

import (
	"context"
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha512"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"strings"
	"sync"
	"time"

	core "github.com/R3E-Network/service_layer/internal/app/core/service"
	domain "github.com/R3E-Network/service_layer/internal/app/domain/random"
	"github.com/R3E-Network/service_layer/internal/app/storage"
	"github.com/R3E-Network/service_layer/pkg/logger"
)

// Service provides random number generation utilities.
type Service struct {
	base    *core.Base
	log     *logger.Logger
	priv    ed25519.PrivateKey
	pub     ed25519.PublicKey
	mu      sync.Mutex
	counter uint64
}

// Option configures the randomness service.
type Option func(*Service) error

// New constructs a random service.
func New(accounts storage.AccountStore, log *logger.Logger, opts ...Option) *Service {
	if log == nil {
		log = logger.NewDefault("random")
	}
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(fmt.Sprintf("generate ed25519 key: %v", err))
	}
	svc := &Service{
		base: core.NewBase(accounts),
		log:  log,
		priv: priv,
		pub:  pub,
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(svc); err != nil {
			panic(fmt.Sprintf("random service option: %v", err))
		}
	}
	return svc
}

// Generate returns cryptographically secure random bytes of the requested length.
func (s *Service) Generate(ctx context.Context, accountID string, length int, requestID string) (domain.Result, error) {
	if err := s.base.EnsureAccount(ctx, accountID); err != nil {
		return domain.Result{}, err
	}
	_ = ctx
	if length <= 0 || length > 1024 {
		return domain.Result{}, fmt.Errorf("length must be between 1 and 1024")
	}

	reqID := strings.TrimSpace(requestID)
	now := time.Now().UTC()
	nonce := s.nextCounter()
	msg := buildMessage(reqID, nonce, now, length)
	sig := ed25519.Sign(s.priv, msg)
	value, err := deriveRandom(sig, msg, length)
	if err != nil {
		return domain.Result{}, err
	}

	s.log.Debugf("generated %d random bytes", length)
	return domain.Result{
		Value:     value,
		CreatedAt: now,
		Signature: sig,
		PublicKey: append([]byte(nil), s.pub...),
		RequestID: reqID,
		Counter:   nonce,
		Length:    length,
	}, nil
}

// EncodeResult encodes the random bytes using base64 for transport.
func EncodeResult(res domain.Result) string {
	return base64.StdEncoding.EncodeToString(res.Value)
}

// Verify checks whether the provided result and signature were generated by this service.
func (s *Service) Verify(res domain.Result) bool {
	if len(res.Value) == 0 || len(res.Signature) == 0 {
		return false
	}
	pub := s.pub
	if len(res.PublicKey) == ed25519.PublicKeySize {
		pub = ed25519.PublicKey(res.PublicKey)
	}
	msg := buildMessage(res.RequestID, res.Counter, res.CreatedAt, res.Length)
	if !ed25519.Verify(pub, msg, res.Signature) {
		return false
	}
	derived, err := deriveRandom(res.Signature, msg, res.Length)
	if err != nil {
		return false
	}
	if len(derived) != len(res.Value) {
		return false
	}
	for i := range derived {
		if derived[i] != res.Value[i] {
			return false
		}
	}
	return true
}

// Descriptor advertises the service placement and capabilities.
func (s *Service) Descriptor() core.Descriptor {
	return core.Descriptor{
		Name:         "random",
		Domain:       "random",
		Layer:        core.LayerEngine,
		Capabilities: []string{"randomness"},
	}
}

// WithSigningKey configures the service to use the provided ed25519 private key.
// The key must be 64 bytes (private + public appended as per ed25519 specification).
func WithSigningKey(privateKey []byte) Option {
	return func(s *Service) error {
		if len(privateKey) != ed25519.PrivateKeySize {
			return fmt.Errorf("expected %d-byte private key", ed25519.PrivateKeySize)
		}
		s.priv = ed25519.PrivateKey(append([]byte(nil), privateKey...))
		s.pub = s.priv.Public().(ed25519.PublicKey)
		return nil
	}
}

func (s *Service) nextCounter() uint64 {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.counter++
	return s.counter
}

func buildMessage(requestID string, counter uint64, ts time.Time, length int) []byte {
	reqBytes := []byte(requestID)
	msg := make([]byte, 0, len(reqBytes)+1+8+8+4)
	msg = append(msg, reqBytes...)
	msg = append(msg, 0)
	var buf [8]byte
	binary.BigEndian.PutUint64(buf[:], counter)
	msg = append(msg, buf[:]...)
	binary.BigEndian.PutUint64(buf[:], uint64(ts.UnixNano()))
	msg = append(msg, buf[:]...)
	var lenBuf [4]byte
	binary.BigEndian.PutUint32(lenBuf[:], uint32(length))
	msg = append(msg, lenBuf[:]...)
	return msg
}

func deriveRandom(signature, info []byte, length int) ([]byte, error) {
	var result []byte
	var previous []byte
	block := byte(1)
	for len(result) < length {
		h := hmac.New(sha512.New, signature)
		h.Write(previous)
		h.Write(info)
		h.Write([]byte{block})
		previous = h.Sum(nil)
		result = append(result, previous...)
		block++
	}
	return result[:length], nil
}
