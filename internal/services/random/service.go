package random

import (
	"context"
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha512"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"strings"
	"sync"
	"time"

	domain "github.com/R3E-Network/service_layer/internal/app/domain/random"
	"github.com/R3E-Network/service_layer/internal/app/storage"
	engine "github.com/R3E-Network/service_layer/internal/engine"
	"github.com/R3E-Network/service_layer/internal/framework"
	core "github.com/R3E-Network/service_layer/internal/services/core"
	"github.com/R3E-Network/service_layer/pkg/logger"
)

// Service provides random number generation utilities.
type Service struct {
	framework.ServiceBase
	base    *core.Base
	log     *logger.Logger
	priv    ed25519.PrivateKey
	pub     ed25519.PublicKey
	mu      sync.Mutex
	counter uint64
	history map[string][]domain.Result
	histMu  sync.Mutex
	limit   int
}

const defaultHistoryLimit = 100

// Option configures the randomness service.
type Option func(*Service) error

// New constructs a random service.
func New(accounts storage.AccountStore, log *logger.Logger, opts ...Option) *Service {
	if log == nil {
		log = logger.NewDefault("random")
	}
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(fmt.Sprintf("generate ed25519 key: %v", err))
	}
	svc := &Service{
		base:    core.NewBase(accounts),
		log:     log,
		priv:    priv,
		pub:     pub,
		history: make(map[string][]domain.Result),
		limit:   defaultHistoryLimit,
	}
	for _, opt := range opts {
		if opt == nil {
			continue
		}
		if err := opt(svc); err != nil {
			panic(fmt.Sprintf("random service option: %v", err))
		}
	}
	svc.SetName(svc.Name())
	return svc
}

// Name returns the stable service identifier.
func (s *Service) Name() string { return "random" }

// Domain reports the service domain.
func (s *Service) Domain() string { return "random" }

// Manifest describes the service contract for the engine OS.
func (s *Service) Manifest() *framework.Manifest {
	return &framework.Manifest{
		Name:         s.Name(),
		Domain:       s.Domain(),
		Description:  "Cryptographically secure randomness",
		Layer:        "service",
		DependsOn:    []string{"svc-accounts"},
		RequiresAPIs: []engine.APISurface{engine.APISurfaceAccount},
		Capabilities: []string{"random"},
	}
}

// Descriptor advertises the service for system discovery.
func (s *Service) Descriptor() core.Descriptor {
	return core.Descriptor{
		Name:         s.Name(),
		Domain:       s.Domain(),
		Layer:        core.LayerService,
		Capabilities: []string{"random"},
		DependsOn:    []string{"svc-accounts"},
		RequiresAPIs: []string{string(engine.APISurfaceAccount)},
	}
}

// Start marks readiness.
func (s *Service) Start(ctx context.Context) error { _ = ctx; s.MarkReady(true); return nil }

// Stop clears readiness.
func (s *Service) Stop(ctx context.Context) error { _ = ctx; s.MarkReady(false); return nil }

// Ready reports readiness.
func (s *Service) Ready(ctx context.Context) error {
	return s.ServiceBase.Ready(ctx)
}

// Generate returns cryptographically secure random bytes of the requested length.
func (s *Service) Generate(ctx context.Context, accountID string, length int, requestID string) (domain.Result, error) {
	if err := s.base.EnsureAccount(ctx, accountID); err != nil {
		return domain.Result{}, err
	}
	_ = ctx
	if length <= 0 || length > 1024 {
		return domain.Result{}, fmt.Errorf("length must be between 1 and 1024")
	}

	reqID := strings.TrimSpace(requestID)
	now := time.Now().UTC()
	nonce := s.nextCounter()
	msg := buildMessage(reqID, nonce, now, length)
	sig := ed25519.Sign(s.priv, msg)
	value, err := deriveRandom(sig, msg, length)
	if err != nil {
		return domain.Result{}, err
	}

	s.log.Debugf("generated %d random bytes", length)
	res := domain.Result{
		Value:     value,
		CreatedAt: now,
		Signature: sig,
		PublicKey: append([]byte(nil), s.pub...),
		RequestID: reqID,
		Counter:   nonce,
		Length:    length,
	}
	s.record(accountID, res)
	return res, nil
}

// EncodeResult encodes the random bytes using base64 for transport.
func EncodeResult(res domain.Result) string {
	return base64.StdEncoding.EncodeToString(res.Value)
}

// Verify checks whether the provided result and signature were generated by this service.
func (s *Service) Verify(res domain.Result) bool {
	if len(res.Value) == 0 || len(res.Signature) == 0 {
		return false
	}
	pub := s.pub
	if len(res.PublicKey) == ed25519.PublicKeySize {
		pub = ed25519.PublicKey(res.PublicKey)
	}
	msg := buildMessage(res.RequestID, res.Counter, res.CreatedAt, res.Length)
	if !ed25519.Verify(pub, msg, res.Signature) {
		return false
	}
	derived, err := deriveRandom(res.Signature, msg, res.Length)
	if err != nil {
		return false
	}
	if len(derived) != len(res.Value) {
		return false
	}
	for i := range derived {
		if derived[i] != res.Value[i] {
			return false
		}
	}
	return true
}

// WithSigningKey configures the service to use the provided ed25519 private key.
// The key must be 64 bytes (private + public appended as per ed25519 specification).
func WithSigningKey(privateKey []byte) Option {
	return func(s *Service) error {
		if len(privateKey) != ed25519.PrivateKeySize {
			return fmt.Errorf("expected %d-byte private key", ed25519.PrivateKeySize)
		}
		s.priv = ed25519.PrivateKey(append([]byte(nil), privateKey...))
		s.pub = s.priv.Public().(ed25519.PublicKey)
		return nil
	}
}

// WithHistoryLimit overrides the maximum number of results stored per account.
func WithHistoryLimit(limit int) Option {
	return func(s *Service) error {
		if limit <= 0 {
			return fmt.Errorf("history limit must be positive")
		}
		s.limit = limit
		return nil
	}
}

// List returns recently generated random results for the account (newest first).
func (s *Service) List(ctx context.Context, accountID string, limit int) ([]domain.Result, error) {
	if err := s.base.EnsureAccount(ctx, accountID); err != nil {
		return nil, err
	}
	s.histMu.Lock()
	defer s.histMu.Unlock()
	results := s.history[accountID]
	if len(results) == 0 {
		return nil, nil
	}
	max := len(results)
	if limit > 0 && limit < max {
		max = limit
	}
	out := make([]domain.Result, max)
	for i := 0; i < max; i++ {
		out[i] = results[len(results)-1-i]
	}
	return out, nil
}

func (s *Service) record(accountID string, res domain.Result) {
	s.histMu.Lock()
	defer s.histMu.Unlock()
	history := append(s.history[accountID], res)
	max := s.limit
	if max <= 0 {
		max = defaultHistoryLimit
	}
	if len(history) > max {
		history = history[len(history)-max:]
	}
	s.history[accountID] = history
}

func (s *Service) nextCounter() uint64 {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.counter++
	return s.counter
}

func buildMessage(requestID string, counter uint64, ts time.Time, length int) []byte {
	reqBytes := []byte(requestID)
	msg := make([]byte, 0, len(reqBytes)+1+8+8+4)
	msg = append(msg, reqBytes...)
	msg = append(msg, 0)
	var buf [8]byte
	binary.BigEndian.PutUint64(buf[:], counter)
	msg = append(msg, buf[:]...)
	binary.BigEndian.PutUint64(buf[:], uint64(ts.UnixNano()))
	msg = append(msg, buf[:]...)
	var lenBuf [4]byte
	binary.BigEndian.PutUint32(lenBuf[:], uint32(length))
	msg = append(msg, lenBuf[:]...)
	return msg
}

func deriveRandom(signature, info []byte, length int) ([]byte, error) {
	var result []byte
	var previous []byte
	block := byte(1)
	for len(result) < length {
		h := hmac.New(sha512.New, signature)
		h.Write(previous)
		h.Write(info)
		h.Write([]byte{block})
		previous = h.Sum(nil)
		result = append(result, previous...)
		block++
	}
	return result[:length], nil
}
