<template>
  <view class="theme-coin-flip">
    <!-- Vault Decorations - Generated by Gemini CLI -->
    <view class="neon-accent-left" />
    <view class="neon-accent-right" />
    <view class="hex-decoration hex-1" />
    <view class="hex-decoration hex-2" />
    <view class="vignette-overlay" />

    <view class="data-stream" v-if="activeTab === 'game'">
      <view
        v-for="i in 10"
        :key="i"
        class="stream-line"
        :style="{
          left: i * 10 + '%',
          animationDuration: 2 + Math.random() * 3 + 's',
          animationDelay: Math.random() * 5 + 's',
        }"
      />
    </view>

    <ResponsiveLayout :desktop-breakpoint="1024" :tabs="navTabs" :active-tab="activeTab" @tab-change="activeTab = $event"

      <!-- Desktop Sidebar -->
      <template #desktop-sidebar>
        <view class="desktop-sidebar">
          <text class="sidebar-title">{{ t('overview') }}</text>
        </view>
      </template>
>
      <!-- Chain Warning - Framework Component -->
      <ChainWarning :title="t('wrongChain')" :message="t('wrongChainMessage')" :button-text="t('switchToNeo')" />
      
      <ErrorBoundary 
        @error="handleBoundaryError" 
        @retry="resetGame"
        :fallback-message="t('gameErrorFallback')"
      >
        <!-- Game Tab -->
        <view
          v-if="activeTab === 'game'"
          class="tab-content"
        >
          <!-- Wallet Connection Warning -->
          <view v-if="!address" class="wallet-warning">
            <NeoCard variant="warning" class="text-center">
              <text class="font-bold">{{ t('connectWalletToPlay') }}</text>
              <NeoButton variant="primary" size="sm" class="mt-2" @click="connectWallet">
                {{ t('connectWallet') }}
              </NeoButton>
            </NeoCard>
          </view>

          <!-- Coin Arena -->
          <view class="arena-container">
            <CoinArena
              :display-outcome="displayOutcome"
              :is-flipping="isFlipping"
              :result="result"
              :t="t as (key: string) => string"
            />
          </view>

          <!-- Bet Controls -->
          <view class="controls-container">
            <BetControls
              v-model:choice="choice"
              v-model:betAmount="betAmount"
              :is-flipping="isFlipping"
              :can-bet="canBet"
              :validation-error="validationError"
              :t="t as (key: string) => string"
              @flip="handleFlip"
            />
          </view>

          <!-- Error Message Overlay -->
          <view v-if="errorMessage" class="error-toast" :class="{ 'error-retryable': canRetryError }">
            <text>{{ errorMessage }}</text>
            <view v-if="canRetryError" class="retry-actions">
              <NeoButton variant="secondary" size="sm" @click="retryOperation">
                {{ t('retry') }}
              </NeoButton>
            </view>
          </view>

          <!-- Result Modal -->
          <ResultOverlay
            :visible="showWinOverlay"
            :win-amount="winAmount"
            :t="t as (key: string) => string"
            @close="showWinOverlay = false"
          />
        </view>

        <!-- Stats Tab -->
        <view v-if="activeTab === 'stats'" class="tab-content scrollable">
          <NeoCard variant="erobo" class="mb-6">
            <NeoStats :stats="gameStats" />
          </NeoCard>
        </view>

        <!-- Docs Tab -->
        <view v-if="activeTab === 'docs'" class="tab-content scrollable">
          <NeoDoc
            :title="t('title')"
            :subtitle="t('docSubtitle')"
            :description="t('docDescription')"
            :steps="docSteps"
            :features="docFeatures"
          />
        </view>
      </ErrorBoundary>
    </ResponsiveLayout>
  </view>
</template>

<script setup lang="ts">
import "../../static/coin-flip.css";
import { ref, computed, onUnmounted } from "vue";
import { useWallet } from "@neo/uniapp-sdk";
import type { WalletSDK } from "@neo/types";
import { formatNumber, sleep, toFixed8 } from "@shared/utils/format";
import { requireNeoChain } from "@shared/utils/chain";
import { sha256Hex, sha256HexFromHex } from "@shared/utils/hash";
import { parseInvokeResult, parseStackItem } from "@shared/utils/neo";
import { useI18n } from "@/composables/useI18n";
import { ResponsiveLayout, NeoCard, NeoStats, NeoDoc, NeoButton, type StatItem, ChainWarning, ErrorBoundary } from "@shared/components";
import { audioManager } from "../../utils/audio";
import type { NavTab } from "@shared/components/NavBar.vue";
import { usePaymentFlow } from "@shared/composables/usePaymentFlow";
import { useGameState } from "@shared/composables/useGameState";
import { useErrorHandler } from "@shared/composables/useErrorHandler";

import CoinArena, { type GameResult } from "./components/CoinArena.vue";
import BetControls from "./components/BetControls.vue";
import ResultOverlay from "./components/ResultOverlay.vue";

const { t } = useI18n();
const { handleError, getUserMessage, canRetry, clearError, lastCategory } = useErrorHandler();

const navTabs = computed<NavTab[]>(() => [
  { id: "game", icon: "game", label: t("game") },
  { id: "stats", icon: "chart", label: t("stats") },
  { id: "docs", icon: "book", label: t("docs") },
]);
const activeTab = ref("game");

const docSteps = computed(() => [t("step1"), t("step2"), t("step3"), t("step4")]);
const docFeatures = computed(() => [
  { name: t("feature1Name"), desc: t("feature1Desc") },
  { name: t("feature2Name"), desc: t("feature2Desc") },
]);

const APP_ID = "miniapp-coinflip";
const SCRIPT_NAME = "flip-coin";
const { address, connect, invokeContract, invokeRead, chainType, getContractAddress } = useWallet() as WalletSDK;
const { processPayment, waitForEvent } = usePaymentFlow(APP_ID);

const betAmount = ref("1");
const choice = ref<"heads" | "tails">("heads");
const { wins, losses, winRate, totalGames, recordWin, recordLoss } = useGameState();
const totalWon = ref(0);
const isFlipping = ref(false);
const result = ref<GameResult | null>(null);
const displayOutcome = ref<"heads" | "tails" | null>(null);
const showWinOverlay = ref(false);
const winAmount = ref("0");
const contractAddress = ref<string | null>(null);
const flipScriptHash = ref<string | null>(null);
const errorMessage = ref<string | null>(null);
const validationError = ref<string | null>(null);
const canRetryError = ref(false);
const lastOperation = ref<string | null>(null);

// Timer tracking for cleanup
let errorClearTimer: ReturnType<typeof setTimeout> | null = null;

const formatNum = (n: number) => formatNumber(n, 2);

const MAX_BET = 100;
const MIN_BET = 0.05;

const hexToBigInt = (hex: string): bigint => {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  return BigInt("0x" + cleanHex);
};

const hashSeed = async (seed: string): Promise<string> => {
  const raw = String(seed ?? "").trim();
  const cleaned = raw.replace(/^0x/i, "");
  const isHex = cleaned.length > 0 && /^[0-9a-fA-F]+$/.test(cleaned);
  return isHex ? sha256HexFromHex(cleaned) : sha256Hex(raw);
};

const simulateCoinFlip = async (
  seed: string,
  playerChoice: boolean,
): Promise<{ won: boolean; outcome: "heads" | "tails" }> => {
  const hashHex = await hashSeed(seed);
  const rand = hexToBigInt(hashHex);
  const resultFlip = rand % BigInt(2) === BigInt(0);
  const won = resultFlip === playerChoice;
  const outcome = resultFlip ? "heads" : "tails";
  return { won, outcome };
};

// Enhanced input validation
const validateBetAmount = (amount: string): string | null => {
  const num = parseFloat(amount);
  if (isNaN(num)) {
    return t("invalidAmountNumber");
  }
  if (num < MIN_BET) {
    return t("minBetError").replace("{min}", String(MIN_BET));
  }
  if (num > MAX_BET) {
    return t("maxBetError").replace("{max}", String(MAX_BET));
  }
  if (!/^\d+(\.\d{1,8})?$/.test(amount)) {
    return t("invalidAmountDecimals");
  }
  return null;
};

const canBet = computed(() => {
  const n = parseFloat(betAmount.value);
  return n >= MIN_BET && n <= MAX_BET && !validationError.value;
});

const gameStats = computed<StatItem[]>(() => [
  { label: t("totalGames"), value: wins.value + losses.value },
  { label: t("wins"), value: wins.value, variant: "success" },
  { label: t("losses"), value: losses.value, variant: "danger" },
  { label: t("totalWon"), value: `${formatNum(totalWon.value)} GAS`, variant: "accent" },
]);

const showError = (msg: string, retryable = false) => {
  errorMessage.value = msg;
  canRetryError.value = retryable;
  if (errorClearTimer) clearTimeout(errorClearTimer);
  errorClearTimer = setTimeout(() => {
    errorMessage.value = null;
    canRetryError.value = false;
    errorClearTimer = null;
  }, 5000);
};

const ensureContractAddress = async () => {
  if (!requireNeoChain(chainType, t)) {
    throw new Error(t("wrongChainMessage"));
  }
  if (!contractAddress.value) {
    contractAddress.value = await getContractAddress();
  }
  if (!contractAddress.value) {
    throw new Error(t("contractUnavailable"));
  }
  return contractAddress.value;
};

const ensureScriptHash = async () => {
  if (flipScriptHash.value) return flipScriptHash.value;
  const contract = await ensureContractAddress();
  
  try {
    const info = await invokeRead({ scriptHash: contract, operation: "getFlipScriptInfo" });
    const parsed = parseInvokeResult(info);
    let hash = "";
    if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
      hash = String((parsed as Record<string, unknown>).hash ?? "");
    }
    if (!hash) {
      const direct = await invokeRead({
        scriptHash: contract,
        operation: "getScriptHash",
        args: [{ type: "String", value: SCRIPT_NAME }],
      });
      const parsedDirect = parseInvokeResult(direct);
      hash = Array.isArray(parsedDirect) ? String(parsedDirect[0] ?? "") : String(parsedDirect ?? "");
    }
    if (!hash) {
      throw new Error(t("scriptHashMissing"));
    }
    flipScriptHash.value = hash.replace(/^0x/i, "");
    return flipScriptHash.value;
  } catch (e) {
    handleError(e, { operation: "ensureScriptHash", metadata: { contract } });
    throw e;
  }
};

const connectWallet = async () => {
  try {
    await connect();
  } catch (e) {
    handleError(e, { operation: "connectWallet" });
    showError(getUserMessage(e));
  }
};

const resetGame = () => {
  isFlipping.value = false;
  result.value = null;
  displayOutcome.value = null;
  showWinOverlay.value = false;
  clearError();
};

const handleBoundaryError = (error: Error) => {
  handleError(error, { operation: "boundaryError" });
  showError(t("gameErrorFallback"));
};

const retryOperation = () => {
  if (lastOperation.value === "flip") {
    handleFlip();
  }
};

const handleFlip = async () => {
  // Validate inputs
  const validation = validateBetAmount(betAmount.value);
  if (validation) {
    validationError.value = validation;
    showError(validation);
    return;
  }
  validationError.value = null;

  // Check wallet connection
  if (!address.value) {
    try {
      await connect();
    } catch (e) {
      handleError(e, { operation: "connectBeforeFlip" });
      showError(t("connectWalletToPlay"));
      return;
    }
  }

  if (!address.value) {
    showError(t("connectWalletToPlay"));
    return;
  }

  if (isFlipping.value || !canBet.value) return;

  isFlipping.value = true;
  result.value = null;
  displayOutcome.value = null;
  showWinOverlay.value = false;
  lastOperation.value = "flip";

  try {
    const contract = await ensureContractAddress();

    const amountBase = toFixed8(betAmount.value);
    if (amountBase === "0") {
      throw new Error(t("invalidBetAmount"));
    }

    // Process payment and get invoke function
    const { receiptId, invoke: invokeWithReceipt } = await processPayment(
      betAmount.value,
      `coinflip:${choice.value}:${betAmount.value}`,
    );

    // Initiate bet using the invoke function from payment flow
    const initiateResult = (await invokeWithReceipt("initiateBet", [
      { type: "Hash160", value: address.value as string },
      { type: "Integer", value: amountBase },
      { type: "Boolean", value: choice.value === "heads" },
      { type: "Integer", value: String(receiptId) },
    ])) as { txid: string; receiptId: string };

    const initiateTxid = initiateResult.txid;
    const initiatedEvent = initiateTxid ? await waitForEvent(initiateTxid, "BetInitiated") : null;
    if (!initiatedEvent) {
      throw new Error(t("betPending"));
    }

    const initiatedValues = Array.isArray((initiatedEvent as any)?.state)
      ? (initiatedEvent as any).state.map(parseStackItem)
      : [];
    const betId = String(initiatedValues[1] ?? "");
    const seed = String(initiatedValues[4] ?? "");
    if (!betId || !seed) {
      throw new Error(t("betMissing"));
    }

    audioManager.play("flip");
    const playerChoice = choice.value === "heads";
    const simulated = await simulateCoinFlip(seed, playerChoice);

    displayOutcome.value = simulated.outcome;
    await sleep(400);
    isFlipping.value = false;
    result.value = { won: simulated.won, outcome: simulated.outcome.toUpperCase() };

    if (simulated.won) audioManager.play("win");
    else audioManager.play("lose");

    const scriptHash = await ensureScriptHash();
    
    try {
      const settleTx = await invokeContract({
        scriptHash: contract,
        operation: "settleBet",
        args: [
          { type: "Hash160", value: address.value as string },
          { type: "Integer", value: betId },
          { type: "Boolean", value: simulated.won },
          { type: "ByteArray", value: scriptHash },
        ],
      });

      const settleTxid = String((settleTx as any)?.txid || (settleTx as any)?.txHash || "");
      if (settleTxid) {
        const resolvedEvent = await waitForEvent(settleTxid, "BetResolved");
        if (resolvedEvent) {
          const values = Array.isArray((resolvedEvent as any)?.state)
            ? (resolvedEvent as any).state.map(parseStackItem)
            : [];
          const payoutRaw = values[3];
          const payoutValue = Number(payoutRaw || 0) / 1e8;

          if (simulated.won) {
            recordWin(payoutValue);
            totalWon.value += payoutValue;
            winAmount.value = payoutValue.toFixed(2);
            showWinOverlay.value = true;
          } else {
            recordLoss();
          }
        }
      }
    } catch (settleError) {
      // Log settlement error but don't block user - bet was already placed
      handleError(settleError, { operation: "settleBet", metadata: { betId, won: simulated.won } });
      if (simulated.won) {
        recordWin(0);
      } else {
        recordLoss();
      }
    }
  } catch (e: unknown) {
    handleError(e, { operation: "flip", metadata: { betAmount: betAmount.value, choice: choice.value } });
    const userMsg = getUserMessage(e);
    const retryable = canRetry(e);
    showError(userMsg, retryable);
    isFlipping.value = false;
  }
};

onUnmounted(() => {
  if (errorClearTimer) {
    clearTimeout(errorClearTimer);
    errorClearTimer = null;
  }
});
</script>

<style lang="scss" scoped>
@use "@shared/styles/tokens.scss" as *;
@use "@shared/styles/variables.scss";
@import "./coin-flip-theme.scss";

.tab-content {
  padding: 20px;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 24px;
  background: var(--bg-primary);
  color: var(--text-primary);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
  z-index: 1;
}

.arena-container {
  width: 100%;
  margin-top: 10px;
}

.controls-container {
  width: 100%;
}

.wallet-warning {
  margin-bottom: 16px;
}

.error-toast {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--coin-error-bg);
  color: var(--coin-error-text);
  padding: 12px 24px;
  border-radius: 99px;
  font-weight: 700;
  font-size: 14px;
  backdrop-filter: blur(10px);
  z-index: 3000;
  box-shadow: var(--coin-error-shadow);
  animation: toast-in 0.3s ease-out;
  max-width: 90%;
  text-align: center;
}

.error-toast.error-retryable {
  padding-bottom: 48px;
}

.retry-actions {
  position: absolute;
  bottom: 8px;
  left: 50%;
  transform: translateX(-50%);
}

@keyframes toast-in {
  from {
    transform: translate(-50%, -20px);
    opacity: 0;
  }
  to {
    transform: translate(-50%, 0);
    opacity: 1;
  }
}

.scrollable {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

:deep(.neo-stats) {
  .stat-card {
    background: var(--coin-stat-bg);
    border: 1px solid var(--coin-stat-border);
  }
  .stat-value {
    font-weight: 900;
    letter-spacing: -1px;
  }
}


// Desktop sidebar
.desktop-sidebar {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-3, 12px);
}

.sidebar-title {
  font-size: var(--font-size-sm, 13px);
  font-weight: 600;
  color: var(--text-secondary, rgba(248, 250, 252, 0.7));
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
</style>
