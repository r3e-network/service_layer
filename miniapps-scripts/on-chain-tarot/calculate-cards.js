/**
 * On-Chain Tarot - Card Calculation Script
 *
 * This script runs in TEE (Trusted Execution Environment) to calculate
 * tarot cards from a deterministic seed generated on-chain.
 *
 * The seed is generated by the contract during InitiateReading() and
 * ensures the same seed always produces the same cards.
 *
 * @param {Object} input - Input parameters
 * @param {string} input.seed - Hex-encoded seed from contract (32 bytes)
 * @param {number} input.cardCount - Number of cards to draw (3, 5, or 10)
 * @returns {Object} - Calculated cards and metadata
 */

const TOTAL_CARDS = 78; // Major (22) + Minor (56) Arcana

/**
 * Convert hex string to byte array.
 */
function hexToBytes(hex) {
  const bytes = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.slice(i, i + 2), 16));
  }
  return bytes;
}

/**
 * Simple hash function for deterministic randomness.
 * Uses seed + index to generate unique values.
 */
function hashWithIndex(seedBytes, index) {
  // Simple mixing: XOR seed bytes with index
  const mixed = seedBytes.map((b, i) => b ^ ((index * 31 + i) & 0xff));

  // Sum and reduce to get a pseudo-random value
  let hash = 0;
  for (let i = 0; i < mixed.length; i++) {
    hash = ((hash << 5) - hash + mixed[i]) | 0;
  }
  return Math.abs(hash);
}

/**
 * Calculate cards from seed using Fisher-Yates shuffle variant.
 */
function calculateCards(input) {
  const { seed, cardCount } = input;

  // Validate inputs
  if (!seed || typeof seed !== "string") {
    throw new Error("seed is required and must be a hex string");
  }
  if (!cardCount || ![3, 5, 10].includes(cardCount)) {
    throw new Error("cardCount must be 3, 5, or 10");
  }

  const seedBytes = hexToBytes(seed.replace(/^0x/, ""));
  if (seedBytes.length !== 32) {
    throw new Error("seed must be 32 bytes (64 hex chars)");
  }

  // Create deck [0, 1, 2, ..., 77]
  const deck = Array.from({ length: TOTAL_CARDS }, (_, i) => i);

  // Draw cards using deterministic shuffle
  const drawnCards = [];
  for (let i = 0; i < cardCount; i++) {
    const remaining = TOTAL_CARDS - i;
    const randValue = hashWithIndex(seedBytes, i);
    const pickIndex = randValue % remaining;

    // Swap picked card to end
    const pickedCard = deck[pickIndex];
    deck[pickIndex] = deck[remaining - 1];
    deck[remaining - 1] = pickedCard;

    // Determine if reversed (use next hash value)
    const reversedHash = hashWithIndex(seedBytes, i + 100);
    const isReversed = (reversedHash % 2) === 1;

    drawnCards.push({
      cardIndex: pickedCard,
      position: i,
      reversed: isReversed,
    });
  }

  // Return result
  return {
    cards: drawnCards.map((c) => c.cardIndex),
    cardDetails: drawnCards,
    metadata: {
      seedUsed: seed,
      cardCount: cardCount,
      algorithm: "fisher-yates-deterministic",
      version: "1.0.0",
    },
  };
}

// Export for TEE execution
module.exports = { calculateCards };
