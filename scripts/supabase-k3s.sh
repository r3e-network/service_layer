#!/bin/bash
# =============================================================================
# Supabase k3s Deployment Script
# Deploys self-hosted Supabase (PostgreSQL + PostgREST + GoTrue) to k3s
# =============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
K8S_DIR="$PROJECT_ROOT/k8s"
SUPABASE_DIR="$K8S_DIR/supabase"
SECRETS_FILE="$SUPABASE_DIR/base/secrets.yaml"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Generate random password
generate_password() {
    openssl rand -base64 32 | tr -d "=+/" | cut -c1-32
}

# Generate JWT secret
generate_jwt_secret() {
    openssl rand -base64 32
}

# Generate JWT token
generate_jwt_token() {
    local secret="$1"
    local role="$2"
    local iat=$(date +%s)
    local exp=1957345300  # Far future expiry (2032)

    # JWT Header
    local header='{"alg":"HS256","typ":"JWT"}'
    local header_b64=$(echo -n "$header" | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

    # JWT Payload
    local payload="{\"iss\":\"supabase\",\"ref\":\"local\",\"role\":\"$role\",\"iat\":$iat,\"exp\":$exp}"
    local payload_b64=$(echo -n "$payload" | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

    # JWT Signature
    local signature=$(echo -n "${header_b64}.${payload_b64}" | openssl dgst -sha256 -hmac "$secret" -binary | openssl base64 -e -A | tr '+/' '-_' | tr -d '=')

    echo "${header_b64}.${payload_b64}.${signature}"
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."

    if ! command_exists kubectl; then
        log_error "kubectl is not installed. Please install kubectl first."
        exit 1
    fi

    if ! command_exists openssl; then
        log_error "openssl is not installed. Please install openssl first."
        exit 1
    fi

    # Check if k3s is running
    if ! kubectl cluster-info &>/dev/null; then
        log_error "Cannot connect to Kubernetes cluster. Is k3s running?"
        exit 1
    fi

    log_success "Prerequisites check passed"
}

# Generate secrets
generate_secrets() {
    log_info "Generating Supabase secrets..."

    local postgres_password=""
    local jwt_secret=""
    local anon_key=""
    local service_role_key=""
    local database_url=""

    if [[ -f "$SECRETS_FILE" ]]; then
        log_warn "Secrets file already exists; reusing $SECRETS_FILE"
        postgres_password=$(sed -n 's/^  POSTGRES_PASSWORD: "\(.*\)"$/\1/p' "$SECRETS_FILE")
        database_url=$(sed -n 's/^  DATABASE_URL: "\(.*\)"$/\1/p' "$SECRETS_FILE")
        jwt_secret=$(sed -n 's/^  JWT_SECRET: "\(.*\)"$/\1/p' "$SECRETS_FILE")
        anon_key=$(sed -n 's/^  ANON_KEY: "\(.*\)"$/\1/p' "$SECRETS_FILE")
        service_role_key=$(sed -n 's/^  SERVICE_ROLE_KEY: "\(.*\)"$/\1/p' "$SECRETS_FILE")

        if [[ -z "$postgres_password" || -z "$database_url" || -z "$jwt_secret" || -z "$anon_key" || -z "$service_role_key" ]]; then
            log_error "Failed to parse existing secrets from $SECRETS_FILE; delete it and rerun."
            exit 1
        fi
    else
        postgres_password=$(generate_password)
        jwt_secret=$(generate_jwt_secret)
        anon_key=$(generate_jwt_token "$jwt_secret" "anon")
        service_role_key=$(generate_jwt_token "$jwt_secret" "service_role")
        database_url="postgresql://postgres:${postgres_password}@postgres.supabase.svc.cluster.local:5432/postgres"

        # Create secrets file
        cat > "$SECRETS_FILE" <<EOF
# =============================================================================
# Supabase Secrets (Generated by scripts/supabase-k3s.sh)
# DO NOT commit this file to version control!
# =============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: supabase-secrets
  namespace: supabase
type: Opaque
stringData:
  # PostgreSQL password
  POSTGRES_PASSWORD: "$postgres_password"

  # Database connection URL
  DATABASE_URL: "$database_url"

  # JWT Secret (used for signing tokens)
  JWT_SECRET: "$jwt_secret"

  # Anon Key (JWT with 'anon' role, no expiry)
  ANON_KEY: "$anon_key"

  # Service Role Key (JWT with 'service_role' role, no expiry)
  SERVICE_ROLE_KEY: "$service_role_key"
EOF
    fi

    log_success "Secrets generated and saved to $SECRETS_FILE"

    # Display important values
    echo ""
    log_info "=== Supabase Configuration ==="
    echo "SUPABASE_URL: https://supabase.localhost"
    echo "SUPABASE_ANON_KEY: $anon_key"
    echo "SUPABASE_SERVICE_KEY: $service_role_key"
    echo ""
    log_warn "Save these values! You'll need them to configure your services."
    echo ""

    # Save to .env file for easy reference
    local env_file="$PROJECT_ROOT/.env.supabase"
    cat > "$env_file" <<EOF
# Supabase Configuration (Generated by scripts/supabase-k3s.sh)
SUPABASE_URL=https://supabase.localhost
SUPABASE_ANON_KEY=$anon_key
SUPABASE_SERVICE_KEY=$service_role_key
POSTGRES_PASSWORD=$postgres_password
JWT_SECRET=$jwt_secret
EOF

    log_success "Configuration saved to $env_file"
}

# Create PostgreSQL roles
create_postgres_roles() {
    log_info "Creating PostgreSQL roles..."

    # Wait for PostgreSQL to be ready
    log_info "Waiting for PostgreSQL to be ready..."
    kubectl wait --for=condition=ready pod -l app=postgres -n supabase --timeout=300s || {
        log_error "PostgreSQL pod did not become ready in time"
        return 1
    }

    # Get the postgres pod name
    local postgres_pod=$(kubectl get pod -n supabase -l app=postgres -o jsonpath='{.items[0].metadata.name}')

    # Create anon and service_role roles
    log_info "Creating database roles..."
    if ! kubectl exec -n supabase "$postgres_pod" -- psql -U postgres -d postgres <<'EOSQL'
-- Create anon role
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'anon') THEN
        CREATE ROLE anon NOLOGIN;
    END IF;
END
$$;

-- Create service_role role
DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'service_role') THEN
        CREATE ROLE service_role NOLOGIN BYPASSRLS;
    END IF;
END
$$;

-- Grant permissions
GRANT USAGE ON SCHEMA public TO anon, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon, service_role;

-- Set default privileges
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO anon, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO anon, service_role;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO anon, service_role;
EOSQL
    then
        log_warn "Failed to create roles (they may already exist)"
    fi

    log_success "PostgreSQL roles created"
}

# Deploy Supabase
deploy_supabase() {
    log_info "Deploying Supabase to k3s..."

    # Apply the kustomization (allow loading migrations from repo root)
    kubectl kustomize --load-restrictor=LoadRestrictionsNone "$SUPABASE_DIR/overlays/local" | kubectl apply -f -

    log_success "Supabase manifests applied"

    # Wait for deployments to be ready
    log_info "Waiting for Supabase components to be ready..."

    log_info "Waiting for PostgreSQL..."
    kubectl wait --for=condition=ready pod -l app=postgres -n supabase --timeout=300s || {
        log_error "PostgreSQL failed to start"
        kubectl logs -n supabase -l app=postgres --tail=50
        exit 1
    }

    log_info "Waiting for PostgREST..."
    kubectl wait --for=condition=ready pod -l app=postgrest -n supabase --timeout=180s || {
        log_error "PostgREST failed to start"
        kubectl logs -n supabase -l app=postgrest --tail=50
        exit 1
    }

    log_info "Waiting for GoTrue..."
    kubectl wait --for=condition=ready pod -l app=gotrue -n supabase --timeout=180s || {
        log_error "GoTrue failed to start"
        kubectl logs -n supabase -l app=gotrue --tail=50
        exit 1
    }

    log_success "All Supabase components are ready"
}

# Verify deployment
verify_deployment() {
    log_info "Verifying Supabase deployment..."

    # Check pods
    log_info "Checking pod status..."
    kubectl get pods -n supabase

    # Check services
    log_info "Checking services..."
    kubectl get svc -n supabase

    # Check ingress
    log_info "Checking ingress..."
    kubectl get ingress -n supabase

    # Test PostgREST endpoint
    log_info "Testing PostgREST endpoint..."
    local anon_key=$(kubectl get secret supabase-secrets -n supabase -o jsonpath='{.data.ANON_KEY}' | base64 -d)

    # Note: This will fail if ingress/TLS is not set up yet
    log_info "To test the API, run:"
    echo "  curl -k https://supabase.localhost/rest/v1/ -H \"apikey: $anon_key\""
    echo ""

    log_success "Deployment verification complete"
}

# Update service-layer ConfigMap
update_service_layer_config() {
    log_info "Updating service-layer ConfigMap..."

    local service_key=$(kubectl get secret supabase-secrets -n supabase -o jsonpath='{.data.SERVICE_ROLE_KEY}' | base64 -d)

    # Check if service-layer namespace exists
    if ! kubectl get namespace service-layer &>/dev/null; then
        log_warn "service-layer namespace does not exist. Skipping ConfigMap update."
        return 0
    fi

    # Update ConfigMap
    kubectl patch configmap service-layer-config -n service-layer --type merge -p "{\"data\":{\"SUPABASE_URL\":\"http://postgrest.supabase.svc.cluster.local:3000\",\"SUPABASE_REST_PREFIX\":\"/\",\"SUPABASE_ALLOW_INSECURE\":\"true\"}}" || {
        log_warn "Failed to update service-layer ConfigMap (it may not exist yet)"
    }

    # Update Secret
    kubectl patch secret service-layer-secrets -n service-layer --type merge -p "{\"stringData\":{\"SUPABASE_SERVICE_KEY\":\"$service_key\"}}" || {
        log_warn "Failed to update service-layer Secret (it may not exist yet)"
    }

    log_success "service-layer configuration updated"
}

# Main function
main() {
    local command="${1:-deploy}"

    case "$command" in
        deploy)
            log_info "Starting Supabase deployment..."
            check_prerequisites
            generate_secrets
            deploy_supabase
            create_postgres_roles
            verify_deployment
            update_service_layer_config
            log_success "Supabase deployment complete!"
            echo ""
            log_info "Next steps:"
            echo "  1. Add supabase.localhost to /etc/hosts: 127.0.0.1 supabase.localhost"
            echo "  2. Test the API: curl -k https://supabase.localhost/rest/v1/"
            echo "  3. Check configuration in .env.supabase"
            ;;

        verify)
            verify_deployment
            ;;

        delete)
            log_warn "Deleting Supabase deployment..."
            kubectl delete -k "$SUPABASE_DIR/overlays/local" || true
            log_success "Supabase deleted"
            ;;

        logs)
            local component="${2:-all}"
            if [ "$component" = "all" ]; then
                kubectl logs -n supabase -l app.kubernetes.io/part-of=supabase --tail=100 -f
            else
                kubectl logs -n supabase -l app="$component" --tail=100 -f
            fi
            ;;

        *)
            echo "Usage: $0 {deploy|verify|delete|logs [component]}"
            echo ""
            echo "Commands:"
            echo "  deploy  - Deploy Supabase to k3s (default)"
            echo "  verify  - Verify Supabase deployment"
            echo "  delete  - Delete Supabase deployment"
            echo "  logs    - Show logs (component: postgres|postgrest|gotrue|all)"
            exit 1
            ;;
    esac
}

main "$@"
